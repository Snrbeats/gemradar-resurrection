// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective_rfqrpc.proto" (package "injective_rfqrpc", syntax proto3)
// tslint:disable
//
// Code generated with goa v3.7.0, DO NOT EDIT.
//
// InjectiveRFQRPC protocol buffer definition
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-indexer/api/design -o ../
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message injective_rfqrpc.RequestRequest
 */
export interface RequestRequest {
    /**
     * RFQ request to create
     *
     * @generated from protobuf field: injective_rfqrpc.RFQRequestType request = 1
     */
    request?: RFQRequestType;
}
/**
 * RFQ request
 *
 * @generated from protobuf message injective_rfqrpc.RFQRequestType
 */
export interface RFQRequestType {
    /**
     * RFQ ID
     *
     * @generated from protobuf field: uint64 rfq_id = 1
     */
    rfqId: bigint;
    /**
     * Market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Direction (long/short)
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * Margin amount
     *
     * @generated from protobuf field: string margin = 4
     */
    margin: string;
    /**
     * Quantity
     *
     * @generated from protobuf field: string quantity = 5
     */
    quantity: string;
    /**
     * Worst acceptable price
     *
     * @generated from protobuf field: string worst_price = 6
     */
    worstPrice: string;
    /**
     * Requester address
     *
     * @generated from protobuf field: string request_address = 7
     */
    requestAddress: string;
    /**
     * Expiry timestamp
     *
     * @generated from protobuf field: uint64 expiry = 8
     */
    expiry: bigint;
    /**
     * Status (open, cancelled, completed)
     *
     * @generated from protobuf field: string status = 9
     */
    status: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: sint64 created_at = 10
     */
    createdAt: bigint;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: sint64 updated_at = 11
     */
    updatedAt: bigint;
    /**
     * Transaction time timestamp
     *
     * @generated from protobuf field: uint64 transaction_time = 12
     */
    transactionTime: bigint;
    /**
     * Block height
     *
     * @generated from protobuf field: uint64 height = 13
     */
    height: bigint;
}
/**
 * @generated from protobuf message injective_rfqrpc.RequestResponse
 */
export interface RequestResponse {
    /**
     * Status of the operation
     *
     * @generated from protobuf field: string status = 1
     */
    status: string;
}
/**
 * @generated from protobuf message injective_rfqrpc.StreamRequestRequest
 */
export interface StreamRequestRequest {
    /**
     * Filter by market IDs
     *
     * @generated from protobuf field: repeated string market_ids = 1
     */
    marketIds: string[];
}
/**
 * @generated from protobuf message injective_rfqrpc.StreamRequestResponse
 */
export interface StreamRequestResponse {
    /**
     * RFQ request update
     *
     * @generated from protobuf field: injective_rfqrpc.RFQRequestType request = 1
     */
    request?: RFQRequestType;
    /**
     * Operation type (insert, update, delete)
     *
     * @generated from protobuf field: string stream_operation = 2
     */
    streamOperation: string;
}
/**
 * @generated from protobuf message injective_rfqrpc.QuoteRequest
 */
export interface QuoteRequest {
    /**
     * RFQ quote to create
     *
     * @generated from protobuf field: injective_rfqrpc.RFQQuoteType quote = 1
     */
    quote?: RFQQuoteType;
}
/**
 * RFQ quote
 *
 * @generated from protobuf message injective_rfqrpc.RFQQuoteType
 */
export interface RFQQuoteType {
    /**
     * Chain ID
     *
     * @generated from protobuf field: string chain_id = 1
     */
    chainId: string;
    /**
     * Contract address
     *
     * @generated from protobuf field: string contract_address = 2
     */
    contractAddress: string;
    /**
     * Market ID
     *
     * @generated from protobuf field: string market_id = 3
     */
    marketId: string;
    /**
     * RFQ ID
     *
     * @generated from protobuf field: uint64 rfq_id = 4
     */
    rfqId: bigint;
    /**
     * Taker direction (long/short)
     *
     * @generated from protobuf field: string taker_direction = 5
     */
    takerDirection: string;
    /**
     * Margin amount
     *
     * @generated from protobuf field: string margin = 6
     */
    margin: string;
    /**
     * Quantity
     *
     * @generated from protobuf field: string quantity = 7
     */
    quantity: string;
    /**
     * Price
     *
     * @generated from protobuf field: string price = 8
     */
    price: string;
    /**
     * Expiry timestamp
     *
     * @generated from protobuf field: uint64 expiry = 9
     */
    expiry: bigint;
    /**
     * Maker address
     *
     * @generated from protobuf field: string maker = 10
     */
    maker: string;
    /**
     * Taker address
     *
     * @generated from protobuf field: string taker = 11
     */
    taker: string;
    /**
     * Signature
     *
     * @generated from protobuf field: string signature = 12
     */
    signature: string;
    /**
     * Status (pending, accepted, rejected, expired)
     *
     * @generated from protobuf field: string status = 13
     */
    status: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: sint64 created_at = 14
     */
    createdAt: bigint;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: sint64 updated_at = 15
     */
    updatedAt: bigint;
    /**
     * Block height
     *
     * @generated from protobuf field: uint64 height = 16
     */
    height: bigint;
    /**
     * Event time timestamp
     *
     * @generated from protobuf field: uint64 event_time = 17
     */
    eventTime: bigint;
    /**
     * Transaction time timestamp
     *
     * @generated from protobuf field: uint64 transaction_time = 18
     */
    transactionTime: bigint;
}
/**
 * @generated from protobuf message injective_rfqrpc.QuoteResponse
 */
export interface QuoteResponse {
    /**
     * Status of the operation
     *
     * @generated from protobuf field: string status = 1
     */
    status: string;
}
/**
 * @generated from protobuf message injective_rfqrpc.StreamQuoteRequest
 */
export interface StreamQuoteRequest {
    /**
     * Filter by addresses
     *
     * @generated from protobuf field: repeated string addresses = 1
     */
    addresses: string[];
}
/**
 * @generated from protobuf message injective_rfqrpc.StreamQuoteResponse
 */
export interface StreamQuoteResponse {
    /**
     * RFQ quote update
     *
     * @generated from protobuf field: injective_rfqrpc.RFQQuoteType quote = 1
     */
    quote?: RFQQuoteType;
    /**
     * Operation type (insert, update, delete)
     *
     * @generated from protobuf field: string stream_operation = 2
     */
    streamOperation: string;
}
/**
 * @generated from protobuf message injective_rfqrpc.GetOpenRequestsRequest
 */
export interface GetOpenRequestsRequest {
}
/**
 * @generated from protobuf message injective_rfqrpc.GetOpenRequestsResponse
 */
export interface GetOpenRequestsResponse {
    /**
     * List of open requests
     *
     * @generated from protobuf field: repeated injective_rfqrpc.RFQRequestType requests = 1
     */
    requests: RFQRequestType[];
}
/**
 * @generated from protobuf message injective_rfqrpc.GetPendingQuotesRequest
 */
export interface GetPendingQuotesRequest {
}
/**
 * @generated from protobuf message injective_rfqrpc.GetPendingQuotesResponse
 */
export interface GetPendingQuotesResponse {
    /**
     * List of pending quotes
     *
     * @generated from protobuf field: repeated injective_rfqrpc.RFQQuoteType quotes = 1
     */
    quotes: RFQQuoteType[];
}
/**
 * @generated from protobuf message injective_rfqrpc.ListSettlementRequest
 */
export interface ListSettlementRequest {
    /**
     * Filter by taker addresses
     *
     * @generated from protobuf field: repeated string addresses = 1
     */
    addresses: string[];
    /**
     * Skip records for pagination
     *
     * @generated from protobuf field: sint64 skip = 2
     */
    skip: bigint;
    /**
     * Limit records for pagination
     *
     * @generated from protobuf field: sint64 limit = 3
     */
    limit: bigint;
}
/**
 * @generated from protobuf message injective_rfqrpc.ListSettlementResponse
 */
export interface ListSettlementResponse {
    /**
     * List of RFQ settlements
     *
     * @generated from protobuf field: repeated injective_rfqrpc.RFQSettlementType settlements = 1
     */
    settlements: RFQSettlementType[];
    /**
     * Total count of records
     *
     * @generated from protobuf field: sint64 total = 2
     */
    total: bigint;
}
/**
 * RFQ settlement
 *
 * @generated from protobuf message injective_rfqrpc.RFQSettlementType
 */
export interface RFQSettlementType {
    /**
     * RFQ ID
     *
     * @generated from protobuf field: uint64 rfq_id = 1
     */
    rfqId: bigint;
    /**
     * Market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Taker address
     *
     * @generated from protobuf field: string taker = 3
     */
    taker: string;
    /**
     * Direction (long/short)
     *
     * @generated from protobuf field: string direction = 4
     */
    direction: string;
    /**
     * Margin amount
     *
     * @generated from protobuf field: string margin = 5
     */
    margin: string;
    /**
     * Quantity
     *
     * @generated from protobuf field: string quantity = 6
     */
    quantity: string;
    /**
     * Worst acceptable price
     *
     * @generated from protobuf field: string worst_price = 7
     */
    worstPrice: string;
    /**
     * Unfilled action details
     *
     * @generated from protobuf field: injective_rfqrpc.RFQSettlementUnfilledActionType unfilled_action = 8
     */
    unfilledAction?: RFQSettlementUnfilledActionType;
    /**
     * Fallback quantity
     *
     * @generated from protobuf field: string fallback_quantity = 9
     */
    fallbackQuantity: string;
    /**
     * Fallback margin
     *
     * @generated from protobuf field: string fallback_margin = 10
     */
    fallbackMargin: string;
    /**
     * Transaction time timestamp
     *
     * @generated from protobuf field: uint64 transaction_time = 11
     */
    transactionTime: bigint;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: sint64 created_at = 12
     */
    createdAt: bigint;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: sint64 updated_at = 13
     */
    updatedAt: bigint;
    /**
     * Event time timestamp
     *
     * @generated from protobuf field: uint64 event_time = 14
     */
    eventTime: bigint;
    /**
     * Block height
     *
     * @generated from protobuf field: uint64 height = 15
     */
    height: bigint;
}
/**
 * Action to take for unfilled quantity - only one field should be set
 *
 * @generated from protobuf message injective_rfqrpc.RFQSettlementUnfilledActionType
 */
export interface RFQSettlementUnfilledActionType {
    /**
     * Limit order action
     *
     * @generated from protobuf field: injective_rfqrpc.RFQSettlementLimitActionType limit = 1
     */
    limit?: RFQSettlementLimitActionType;
    /**
     * Market order action
     *
     * @generated from protobuf field: injective_rfqrpc.RFQSettlementMarketActionType market = 2
     */
    market?: RFQSettlementMarketActionType;
}
/**
 * Limit order action for unfilled quantity
 *
 * @generated from protobuf message injective_rfqrpc.RFQSettlementLimitActionType
 */
export interface RFQSettlementLimitActionType {
    /**
     * Limit price
     *
     * @generated from protobuf field: string price = 1
     */
    price: string;
}
/**
 * Market order action for unfilled quantity
 *
 * @generated from protobuf message injective_rfqrpc.RFQSettlementMarketActionType
 */
export interface RFQSettlementMarketActionType {
}
/**
 * @generated from protobuf message injective_rfqrpc.StreamSettlementRequest
 */
export interface StreamSettlementRequest {
    /**
     * Filter by addresses
     *
     * @generated from protobuf field: repeated string addresses = 1
     */
    addresses: string[];
}
/**
 * @generated from protobuf message injective_rfqrpc.StreamSettlementResponse
 */
export interface StreamSettlementResponse {
    /**
     * RFQ settlement update
     *
     * @generated from protobuf field: injective_rfqrpc.RFQSettlementType settlement = 1
     */
    settlement?: RFQSettlementType;
    /**
     * Operation type (insert, update, delete)
     *
     * @generated from protobuf field: string stream_operation = 2
     */
    streamOperation: string;
}
/**
 * Message sent by taker in bidirectional stream
 *
 * @generated from protobuf message injective_rfqrpc.TakerStreamStreamingRequest
 */
export interface TakerStreamStreamingRequest {
    /**
     * Type: 'request', 'ping'
     *
     * @generated from protobuf field: string message_type = 1
     */
    messageType: string;
    /**
     * RFQ request to create
     *
     * @generated from protobuf field: injective_rfqrpc.CreateRFQRequestType request = 2
     */
    request?: CreateRFQRequestType;
}
/**
 * RFQ request
 *
 * @generated from protobuf message injective_rfqrpc.CreateRFQRequestType
 */
export interface CreateRFQRequestType {
    /**
     * RFQ ID
     *
     * @generated from protobuf field: uint64 rfq_id = 1
     */
    rfqId: bigint;
    /**
     * Market ID
     *
     * @generated from protobuf field: string market_id = 2
     */
    marketId: string;
    /**
     * Direction (long/short)
     *
     * @generated from protobuf field: string direction = 3
     */
    direction: string;
    /**
     * Margin amount
     *
     * @generated from protobuf field: string margin = 4
     */
    margin: string;
    /**
     * Quantity
     *
     * @generated from protobuf field: string quantity = 5
     */
    quantity: string;
    /**
     * Worst acceptable price
     *
     * @generated from protobuf field: string worst_price = 6
     */
    worstPrice: string;
    /**
     * Expiry timestamp
     *
     * @generated from protobuf field: uint64 expiry = 7
     */
    expiry: bigint;
    /**
     * Status (open, cancelled, completed)
     *
     * @generated from protobuf field: string status = 8
     */
    status: string;
    /**
     * Creation timestamp
     *
     * @generated from protobuf field: sint64 created_at = 9
     */
    createdAt: bigint;
    /**
     * Last update timestamp
     *
     * @generated from protobuf field: sint64 updated_at = 10
     */
    updatedAt: bigint;
    /**
     * Transaction time timestamp
     *
     * @generated from protobuf field: uint64 transaction_time = 11
     */
    transactionTime: bigint;
    /**
     * Block height
     *
     * @generated from protobuf field: uint64 height = 12
     */
    height: bigint;
}
/**
 * @generated from protobuf message injective_rfqrpc.TakerStreamResponse
 */
export interface TakerStreamResponse {
    /**
     * Type: 'quote', 'request_ack', 'error', 'pong'
     *
     * @generated from protobuf field: string message_type = 1
     */
    messageType: string;
    /**
     * Quote from market maker
     *
     * @generated from protobuf field: injective_rfqrpc.RFQQuoteType quote = 2
     */
    quote?: RFQQuoteType;
    /**
     * Acknowledgment for request creation
     *
     * @generated from protobuf field: injective_rfqrpc.StreamAck request_ack = 3
     */
    requestAck?: StreamAck;
    /**
     * Error message
     *
     * @generated from protobuf field: injective_rfqrpc.StreamError error = 4
     */
    error?: StreamError;
}
/**
 * Acknowledgment for stream operations
 *
 * @generated from protobuf message injective_rfqrpc.StreamAck
 */
export interface StreamAck {
    /**
     * RFQ ID
     *
     * @generated from protobuf field: uint64 rfq_id = 1
     */
    rfqId: bigint;
    /**
     * Status of the operation
     *
     * @generated from protobuf field: string status = 2
     */
    status: string;
}
/**
 * Error message in stream
 *
 * @generated from protobuf message injective_rfqrpc.StreamError
 */
export interface StreamError {
    /**
     * Error code
     *
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * Error message
     *
     * @generated from protobuf field: string message_ = 2
     */
    message: string;
}
/**
 * Message sent by maker in bidirectional stream
 *
 * @generated from protobuf message injective_rfqrpc.MakerStreamStreamingRequest
 */
export interface MakerStreamStreamingRequest {
    /**
     * Type: 'quote', 'ping'
     *
     * @generated from protobuf field: string message_type = 1
     */
    messageType: string;
    /**
     * Quote to submit
     *
     * @generated from protobuf field: injective_rfqrpc.RFQQuoteType quote = 2
     */
    quote?: RFQQuoteType;
}
/**
 * @generated from protobuf message injective_rfqrpc.MakerStreamResponse
 */
export interface MakerStreamResponse {
    /**
     * Type: 'request', 'quote_ack', 'error', 'pong'
     *
     * @generated from protobuf field: string message_type = 1
     */
    messageType: string;
    /**
     * RFQ request from taker
     *
     * @generated from protobuf field: injective_rfqrpc.RFQRequestType request = 2
     */
    request?: RFQRequestType;
    /**
     * Acknowledgment for quote submission
     *
     * @generated from protobuf field: injective_rfqrpc.StreamAck quote_ack = 3
     */
    quoteAck?: StreamAck;
    /**
     * Error message
     *
     * @generated from protobuf field: injective_rfqrpc.StreamError error = 4
     */
    error?: StreamError;
}
// @generated message type with reflection information, may provide speed optimized methods
class RequestRequest$Type extends MessageType<RequestRequest> {
    constructor() {
        super("injective_rfqrpc.RequestRequest", [
            { no: 1, name: "request", kind: "message", T: () => RFQRequestType }
        ]);
    }
    create(value?: PartialMessage<RequestRequest>): RequestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RequestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestRequest): RequestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_rfqrpc.RFQRequestType request */ 1:
                    message.request = RFQRequestType.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_rfqrpc.RFQRequestType request = 1; */
        if (message.request)
            RFQRequestType.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.RequestRequest
 */
export const RequestRequest = new RequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RFQRequestType$Type extends MessageType<RFQRequestType> {
    constructor() {
        super("injective_rfqrpc.RFQRequestType", [
            { no: 1, name: "rfq_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "worst_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "request_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "expiry", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "transaction_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RFQRequestType>): RFQRequestType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rfqId = 0n;
        message.marketId = "";
        message.direction = "";
        message.margin = "";
        message.quantity = "";
        message.worstPrice = "";
        message.requestAddress = "";
        message.expiry = 0n;
        message.status = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.transactionTime = 0n;
        message.height = 0n;
        if (value !== undefined)
            reflectionMergePartial<RFQRequestType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RFQRequestType): RFQRequestType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rfq_id */ 1:
                    message.rfqId = reader.uint64().toBigInt();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string margin */ 4:
                    message.margin = reader.string();
                    break;
                case /* string quantity */ 5:
                    message.quantity = reader.string();
                    break;
                case /* string worst_price */ 6:
                    message.worstPrice = reader.string();
                    break;
                case /* string request_address */ 7:
                    message.requestAddress = reader.string();
                    break;
                case /* uint64 expiry */ 8:
                    message.expiry = reader.uint64().toBigInt();
                    break;
                case /* string status */ 9:
                    message.status = reader.string();
                    break;
                case /* sint64 created_at */ 10:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 11:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* uint64 transaction_time */ 12:
                    message.transactionTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 height */ 13:
                    message.height = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RFQRequestType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rfq_id = 1; */
        if (message.rfqId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rfqId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string margin = 4; */
        if (message.margin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.margin);
        /* string quantity = 5; */
        if (message.quantity !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.quantity);
        /* string worst_price = 6; */
        if (message.worstPrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.worstPrice);
        /* string request_address = 7; */
        if (message.requestAddress !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.requestAddress);
        /* uint64 expiry = 8; */
        if (message.expiry !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.expiry);
        /* string status = 9; */
        if (message.status !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.status);
        /* sint64 created_at = 10; */
        if (message.createdAt !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 11; */
        if (message.updatedAt !== 0n)
            writer.tag(11, WireType.Varint).sint64(message.updatedAt);
        /* uint64 transaction_time = 12; */
        if (message.transactionTime !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.transactionTime);
        /* uint64 height = 13; */
        if (message.height !== 0n)
            writer.tag(13, WireType.Varint).uint64(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.RFQRequestType
 */
export const RFQRequestType = new RFQRequestType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestResponse$Type extends MessageType<RequestResponse> {
    constructor() {
        super("injective_rfqrpc.RequestResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestResponse>): RequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<RequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestResponse): RequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.RequestResponse
 */
export const RequestResponse = new RequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamRequestRequest$Type extends MessageType<StreamRequestRequest> {
    constructor() {
        super("injective_rfqrpc.StreamRequestRequest", [
            { no: 1, name: "market_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamRequestRequest>): StreamRequestRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.marketIds = [];
        if (value !== undefined)
            reflectionMergePartial<StreamRequestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamRequestRequest): StreamRequestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string market_ids */ 1:
                    message.marketIds.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamRequestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string market_ids = 1; */
        for (let i = 0; i < message.marketIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.StreamRequestRequest
 */
export const StreamRequestRequest = new StreamRequestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamRequestResponse$Type extends MessageType<StreamRequestResponse> {
    constructor() {
        super("injective_rfqrpc.StreamRequestResponse", [
            { no: 1, name: "request", kind: "message", T: () => RFQRequestType },
            { no: 2, name: "stream_operation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamRequestResponse>): StreamRequestResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamOperation = "";
        if (value !== undefined)
            reflectionMergePartial<StreamRequestResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamRequestResponse): StreamRequestResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_rfqrpc.RFQRequestType request */ 1:
                    message.request = RFQRequestType.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* string stream_operation */ 2:
                    message.streamOperation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamRequestResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_rfqrpc.RFQRequestType request = 1; */
        if (message.request)
            RFQRequestType.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string stream_operation = 2; */
        if (message.streamOperation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.streamOperation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.StreamRequestResponse
 */
export const StreamRequestResponse = new StreamRequestResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuoteRequest$Type extends MessageType<QuoteRequest> {
    constructor() {
        super("injective_rfqrpc.QuoteRequest", [
            { no: 1, name: "quote", kind: "message", T: () => RFQQuoteType }
        ]);
    }
    create(value?: PartialMessage<QuoteRequest>): QuoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<QuoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuoteRequest): QuoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_rfqrpc.RFQQuoteType quote */ 1:
                    message.quote = RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options, message.quote);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_rfqrpc.RFQQuoteType quote = 1; */
        if (message.quote)
            RFQQuoteType.internalBinaryWrite(message.quote, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.QuoteRequest
 */
export const QuoteRequest = new QuoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RFQQuoteType$Type extends MessageType<RFQQuoteType> {
    constructor() {
        super("injective_rfqrpc.RFQQuoteType", [
            { no: 1, name: "chain_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "rfq_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "taker_direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "expiry", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "maker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "taker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 17, name: "event_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 18, name: "transaction_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RFQQuoteType>): RFQQuoteType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chainId = "";
        message.contractAddress = "";
        message.marketId = "";
        message.rfqId = 0n;
        message.takerDirection = "";
        message.margin = "";
        message.quantity = "";
        message.price = "";
        message.expiry = 0n;
        message.maker = "";
        message.taker = "";
        message.signature = "";
        message.status = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.height = 0n;
        message.eventTime = 0n;
        message.transactionTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<RFQQuoteType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RFQQuoteType): RFQQuoteType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string chain_id */ 1:
                    message.chainId = reader.string();
                    break;
                case /* string contract_address */ 2:
                    message.contractAddress = reader.string();
                    break;
                case /* string market_id */ 3:
                    message.marketId = reader.string();
                    break;
                case /* uint64 rfq_id */ 4:
                    message.rfqId = reader.uint64().toBigInt();
                    break;
                case /* string taker_direction */ 5:
                    message.takerDirection = reader.string();
                    break;
                case /* string margin */ 6:
                    message.margin = reader.string();
                    break;
                case /* string quantity */ 7:
                    message.quantity = reader.string();
                    break;
                case /* string price */ 8:
                    message.price = reader.string();
                    break;
                case /* uint64 expiry */ 9:
                    message.expiry = reader.uint64().toBigInt();
                    break;
                case /* string maker */ 10:
                    message.maker = reader.string();
                    break;
                case /* string taker */ 11:
                    message.taker = reader.string();
                    break;
                case /* string signature */ 12:
                    message.signature = reader.string();
                    break;
                case /* string status */ 13:
                    message.status = reader.string();
                    break;
                case /* sint64 created_at */ 14:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 15:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* uint64 height */ 16:
                    message.height = reader.uint64().toBigInt();
                    break;
                case /* uint64 event_time */ 17:
                    message.eventTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 transaction_time */ 18:
                    message.transactionTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RFQQuoteType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string chain_id = 1; */
        if (message.chainId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.chainId);
        /* string contract_address = 2; */
        if (message.contractAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contractAddress);
        /* string market_id = 3; */
        if (message.marketId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.marketId);
        /* uint64 rfq_id = 4; */
        if (message.rfqId !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.rfqId);
        /* string taker_direction = 5; */
        if (message.takerDirection !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.takerDirection);
        /* string margin = 6; */
        if (message.margin !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.margin);
        /* string quantity = 7; */
        if (message.quantity !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.quantity);
        /* string price = 8; */
        if (message.price !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.price);
        /* uint64 expiry = 9; */
        if (message.expiry !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.expiry);
        /* string maker = 10; */
        if (message.maker !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.maker);
        /* string taker = 11; */
        if (message.taker !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.taker);
        /* string signature = 12; */
        if (message.signature !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.signature);
        /* string status = 13; */
        if (message.status !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.status);
        /* sint64 created_at = 14; */
        if (message.createdAt !== 0n)
            writer.tag(14, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 15; */
        if (message.updatedAt !== 0n)
            writer.tag(15, WireType.Varint).sint64(message.updatedAt);
        /* uint64 height = 16; */
        if (message.height !== 0n)
            writer.tag(16, WireType.Varint).uint64(message.height);
        /* uint64 event_time = 17; */
        if (message.eventTime !== 0n)
            writer.tag(17, WireType.Varint).uint64(message.eventTime);
        /* uint64 transaction_time = 18; */
        if (message.transactionTime !== 0n)
            writer.tag(18, WireType.Varint).uint64(message.transactionTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.RFQQuoteType
 */
export const RFQQuoteType = new RFQQuoteType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QuoteResponse$Type extends MessageType<QuoteResponse> {
    constructor() {
        super("injective_rfqrpc.QuoteResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<QuoteResponse>): QuoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<QuoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuoteResponse): QuoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QuoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.QuoteResponse
 */
export const QuoteResponse = new QuoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamQuoteRequest$Type extends MessageType<StreamQuoteRequest> {
    constructor() {
        super("injective_rfqrpc.StreamQuoteRequest", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamQuoteRequest>): StreamQuoteRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addresses = [];
        if (value !== undefined)
            reflectionMergePartial<StreamQuoteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamQuoteRequest): StreamQuoteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamQuoteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.StreamQuoteRequest
 */
export const StreamQuoteRequest = new StreamQuoteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamQuoteResponse$Type extends MessageType<StreamQuoteResponse> {
    constructor() {
        super("injective_rfqrpc.StreamQuoteResponse", [
            { no: 1, name: "quote", kind: "message", T: () => RFQQuoteType },
            { no: 2, name: "stream_operation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamQuoteResponse>): StreamQuoteResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamOperation = "";
        if (value !== undefined)
            reflectionMergePartial<StreamQuoteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamQuoteResponse): StreamQuoteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_rfqrpc.RFQQuoteType quote */ 1:
                    message.quote = RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options, message.quote);
                    break;
                case /* string stream_operation */ 2:
                    message.streamOperation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamQuoteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_rfqrpc.RFQQuoteType quote = 1; */
        if (message.quote)
            RFQQuoteType.internalBinaryWrite(message.quote, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string stream_operation = 2; */
        if (message.streamOperation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.streamOperation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.StreamQuoteResponse
 */
export const StreamQuoteResponse = new StreamQuoteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOpenRequestsRequest$Type extends MessageType<GetOpenRequestsRequest> {
    constructor() {
        super("injective_rfqrpc.GetOpenRequestsRequest", []);
    }
    create(value?: PartialMessage<GetOpenRequestsRequest>): GetOpenRequestsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetOpenRequestsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOpenRequestsRequest): GetOpenRequestsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOpenRequestsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.GetOpenRequestsRequest
 */
export const GetOpenRequestsRequest = new GetOpenRequestsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOpenRequestsResponse$Type extends MessageType<GetOpenRequestsResponse> {
    constructor() {
        super("injective_rfqrpc.GetOpenRequestsResponse", [
            { no: 1, name: "requests", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RFQRequestType }
        ]);
    }
    create(value?: PartialMessage<GetOpenRequestsResponse>): GetOpenRequestsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requests = [];
        if (value !== undefined)
            reflectionMergePartial<GetOpenRequestsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOpenRequestsResponse): GetOpenRequestsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_rfqrpc.RFQRequestType requests */ 1:
                    message.requests.push(RFQRequestType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOpenRequestsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_rfqrpc.RFQRequestType requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            RFQRequestType.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.GetOpenRequestsResponse
 */
export const GetOpenRequestsResponse = new GetOpenRequestsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPendingQuotesRequest$Type extends MessageType<GetPendingQuotesRequest> {
    constructor() {
        super("injective_rfqrpc.GetPendingQuotesRequest", []);
    }
    create(value?: PartialMessage<GetPendingQuotesRequest>): GetPendingQuotesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPendingQuotesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPendingQuotesRequest): GetPendingQuotesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPendingQuotesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.GetPendingQuotesRequest
 */
export const GetPendingQuotesRequest = new GetPendingQuotesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPendingQuotesResponse$Type extends MessageType<GetPendingQuotesResponse> {
    constructor() {
        super("injective_rfqrpc.GetPendingQuotesResponse", [
            { no: 1, name: "quotes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RFQQuoteType }
        ]);
    }
    create(value?: PartialMessage<GetPendingQuotesResponse>): GetPendingQuotesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.quotes = [];
        if (value !== undefined)
            reflectionMergePartial<GetPendingQuotesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPendingQuotesResponse): GetPendingQuotesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_rfqrpc.RFQQuoteType quotes */ 1:
                    message.quotes.push(RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPendingQuotesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_rfqrpc.RFQQuoteType quotes = 1; */
        for (let i = 0; i < message.quotes.length; i++)
            RFQQuoteType.internalBinaryWrite(message.quotes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.GetPendingQuotesResponse
 */
export const GetPendingQuotesResponse = new GetPendingQuotesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSettlementRequest$Type extends MessageType<ListSettlementRequest> {
    constructor() {
        super("injective_rfqrpc.ListSettlementRequest", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "skip", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "limit", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListSettlementRequest>): ListSettlementRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addresses = [];
        message.skip = 0n;
        message.limit = 0n;
        if (value !== undefined)
            reflectionMergePartial<ListSettlementRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSettlementRequest): ListSettlementRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                case /* sint64 skip */ 2:
                    message.skip = reader.sint64().toBigInt();
                    break;
                case /* sint64 limit */ 3:
                    message.limit = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSettlementRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        /* sint64 skip = 2; */
        if (message.skip !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.skip);
        /* sint64 limit = 3; */
        if (message.limit !== 0n)
            writer.tag(3, WireType.Varint).sint64(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.ListSettlementRequest
 */
export const ListSettlementRequest = new ListSettlementRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSettlementResponse$Type extends MessageType<ListSettlementResponse> {
    constructor() {
        super("injective_rfqrpc.ListSettlementResponse", [
            { no: 1, name: "settlements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RFQSettlementType },
            { no: 2, name: "total", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ListSettlementResponse>): ListSettlementResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.settlements = [];
        message.total = 0n;
        if (value !== undefined)
            reflectionMergePartial<ListSettlementResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSettlementResponse): ListSettlementResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated injective_rfqrpc.RFQSettlementType settlements */ 1:
                    message.settlements.push(RFQSettlementType.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* sint64 total */ 2:
                    message.total = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSettlementResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated injective_rfqrpc.RFQSettlementType settlements = 1; */
        for (let i = 0; i < message.settlements.length; i++)
            RFQSettlementType.internalBinaryWrite(message.settlements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* sint64 total = 2; */
        if (message.total !== 0n)
            writer.tag(2, WireType.Varint).sint64(message.total);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.ListSettlementResponse
 */
export const ListSettlementResponse = new ListSettlementResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RFQSettlementType$Type extends MessageType<RFQSettlementType> {
    constructor() {
        super("injective_rfqrpc.RFQSettlementType", [
            { no: 1, name: "rfq_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "taker", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "worst_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "unfilled_action", kind: "message", T: () => RFQSettlementUnfilledActionType },
            { no: 9, name: "fallback_quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "fallback_margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "transaction_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "event_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RFQSettlementType>): RFQSettlementType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rfqId = 0n;
        message.marketId = "";
        message.taker = "";
        message.direction = "";
        message.margin = "";
        message.quantity = "";
        message.worstPrice = "";
        message.fallbackQuantity = "";
        message.fallbackMargin = "";
        message.transactionTime = 0n;
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.eventTime = 0n;
        message.height = 0n;
        if (value !== undefined)
            reflectionMergePartial<RFQSettlementType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RFQSettlementType): RFQSettlementType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rfq_id */ 1:
                    message.rfqId = reader.uint64().toBigInt();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string taker */ 3:
                    message.taker = reader.string();
                    break;
                case /* string direction */ 4:
                    message.direction = reader.string();
                    break;
                case /* string margin */ 5:
                    message.margin = reader.string();
                    break;
                case /* string quantity */ 6:
                    message.quantity = reader.string();
                    break;
                case /* string worst_price */ 7:
                    message.worstPrice = reader.string();
                    break;
                case /* injective_rfqrpc.RFQSettlementUnfilledActionType unfilled_action */ 8:
                    message.unfilledAction = RFQSettlementUnfilledActionType.internalBinaryRead(reader, reader.uint32(), options, message.unfilledAction);
                    break;
                case /* string fallback_quantity */ 9:
                    message.fallbackQuantity = reader.string();
                    break;
                case /* string fallback_margin */ 10:
                    message.fallbackMargin = reader.string();
                    break;
                case /* uint64 transaction_time */ 11:
                    message.transactionTime = reader.uint64().toBigInt();
                    break;
                case /* sint64 created_at */ 12:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 13:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* uint64 event_time */ 14:
                    message.eventTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 height */ 15:
                    message.height = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RFQSettlementType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rfq_id = 1; */
        if (message.rfqId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rfqId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string taker = 3; */
        if (message.taker !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.taker);
        /* string direction = 4; */
        if (message.direction !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.direction);
        /* string margin = 5; */
        if (message.margin !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.margin);
        /* string quantity = 6; */
        if (message.quantity !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.quantity);
        /* string worst_price = 7; */
        if (message.worstPrice !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.worstPrice);
        /* injective_rfqrpc.RFQSettlementUnfilledActionType unfilled_action = 8; */
        if (message.unfilledAction)
            RFQSettlementUnfilledActionType.internalBinaryWrite(message.unfilledAction, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string fallback_quantity = 9; */
        if (message.fallbackQuantity !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.fallbackQuantity);
        /* string fallback_margin = 10; */
        if (message.fallbackMargin !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.fallbackMargin);
        /* uint64 transaction_time = 11; */
        if (message.transactionTime !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.transactionTime);
        /* sint64 created_at = 12; */
        if (message.createdAt !== 0n)
            writer.tag(12, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 13; */
        if (message.updatedAt !== 0n)
            writer.tag(13, WireType.Varint).sint64(message.updatedAt);
        /* uint64 event_time = 14; */
        if (message.eventTime !== 0n)
            writer.tag(14, WireType.Varint).uint64(message.eventTime);
        /* uint64 height = 15; */
        if (message.height !== 0n)
            writer.tag(15, WireType.Varint).uint64(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.RFQSettlementType
 */
export const RFQSettlementType = new RFQSettlementType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RFQSettlementUnfilledActionType$Type extends MessageType<RFQSettlementUnfilledActionType> {
    constructor() {
        super("injective_rfqrpc.RFQSettlementUnfilledActionType", [
            { no: 1, name: "limit", kind: "message", T: () => RFQSettlementLimitActionType },
            { no: 2, name: "market", kind: "message", T: () => RFQSettlementMarketActionType }
        ]);
    }
    create(value?: PartialMessage<RFQSettlementUnfilledActionType>): RFQSettlementUnfilledActionType {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RFQSettlementUnfilledActionType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RFQSettlementUnfilledActionType): RFQSettlementUnfilledActionType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_rfqrpc.RFQSettlementLimitActionType limit */ 1:
                    message.limit = RFQSettlementLimitActionType.internalBinaryRead(reader, reader.uint32(), options, message.limit);
                    break;
                case /* injective_rfqrpc.RFQSettlementMarketActionType market */ 2:
                    message.market = RFQSettlementMarketActionType.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RFQSettlementUnfilledActionType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_rfqrpc.RFQSettlementLimitActionType limit = 1; */
        if (message.limit)
            RFQSettlementLimitActionType.internalBinaryWrite(message.limit, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* injective_rfqrpc.RFQSettlementMarketActionType market = 2; */
        if (message.market)
            RFQSettlementMarketActionType.internalBinaryWrite(message.market, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.RFQSettlementUnfilledActionType
 */
export const RFQSettlementUnfilledActionType = new RFQSettlementUnfilledActionType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RFQSettlementLimitActionType$Type extends MessageType<RFQSettlementLimitActionType> {
    constructor() {
        super("injective_rfqrpc.RFQSettlementLimitActionType", [
            { no: 1, name: "price", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RFQSettlementLimitActionType>): RFQSettlementLimitActionType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = "";
        if (value !== undefined)
            reflectionMergePartial<RFQSettlementLimitActionType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RFQSettlementLimitActionType): RFQSettlementLimitActionType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string price */ 1:
                    message.price = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RFQSettlementLimitActionType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string price = 1; */
        if (message.price !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.RFQSettlementLimitActionType
 */
export const RFQSettlementLimitActionType = new RFQSettlementLimitActionType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RFQSettlementMarketActionType$Type extends MessageType<RFQSettlementMarketActionType> {
    constructor() {
        super("injective_rfqrpc.RFQSettlementMarketActionType", []);
    }
    create(value?: PartialMessage<RFQSettlementMarketActionType>): RFQSettlementMarketActionType {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RFQSettlementMarketActionType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RFQSettlementMarketActionType): RFQSettlementMarketActionType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RFQSettlementMarketActionType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.RFQSettlementMarketActionType
 */
export const RFQSettlementMarketActionType = new RFQSettlementMarketActionType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamSettlementRequest$Type extends MessageType<StreamSettlementRequest> {
    constructor() {
        super("injective_rfqrpc.StreamSettlementRequest", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamSettlementRequest>): StreamSettlementRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addresses = [];
        if (value !== undefined)
            reflectionMergePartial<StreamSettlementRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamSettlementRequest): StreamSettlementRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamSettlementRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.StreamSettlementRequest
 */
export const StreamSettlementRequest = new StreamSettlementRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamSettlementResponse$Type extends MessageType<StreamSettlementResponse> {
    constructor() {
        super("injective_rfqrpc.StreamSettlementResponse", [
            { no: 1, name: "settlement", kind: "message", T: () => RFQSettlementType },
            { no: 2, name: "stream_operation", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamSettlementResponse>): StreamSettlementResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamOperation = "";
        if (value !== undefined)
            reflectionMergePartial<StreamSettlementResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamSettlementResponse): StreamSettlementResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* injective_rfqrpc.RFQSettlementType settlement */ 1:
                    message.settlement = RFQSettlementType.internalBinaryRead(reader, reader.uint32(), options, message.settlement);
                    break;
                case /* string stream_operation */ 2:
                    message.streamOperation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamSettlementResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* injective_rfqrpc.RFQSettlementType settlement = 1; */
        if (message.settlement)
            RFQSettlementType.internalBinaryWrite(message.settlement, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string stream_operation = 2; */
        if (message.streamOperation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.streamOperation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.StreamSettlementResponse
 */
export const StreamSettlementResponse = new StreamSettlementResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakerStreamStreamingRequest$Type extends MessageType<TakerStreamStreamingRequest> {
    constructor() {
        super("injective_rfqrpc.TakerStreamStreamingRequest", [
            { no: 1, name: "message_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => CreateRFQRequestType }
        ]);
    }
    create(value?: PartialMessage<TakerStreamStreamingRequest>): TakerStreamStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageType = "";
        if (value !== undefined)
            reflectionMergePartial<TakerStreamStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakerStreamStreamingRequest): TakerStreamStreamingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_type */ 1:
                    message.messageType = reader.string();
                    break;
                case /* injective_rfqrpc.CreateRFQRequestType request */ 2:
                    message.request = CreateRFQRequestType.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakerStreamStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_type = 1; */
        if (message.messageType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageType);
        /* injective_rfqrpc.CreateRFQRequestType request = 2; */
        if (message.request)
            CreateRFQRequestType.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.TakerStreamStreamingRequest
 */
export const TakerStreamStreamingRequest = new TakerStreamStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateRFQRequestType$Type extends MessageType<CreateRFQRequestType> {
    constructor() {
        super("injective_rfqrpc.CreateRFQRequestType", [
            { no: 1, name: "rfq_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "market_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "direction", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "margin", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "quantity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "worst_price", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "expiry", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "created_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "updated_at", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "transaction_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "height", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CreateRFQRequestType>): CreateRFQRequestType {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rfqId = 0n;
        message.marketId = "";
        message.direction = "";
        message.margin = "";
        message.quantity = "";
        message.worstPrice = "";
        message.expiry = 0n;
        message.status = "";
        message.createdAt = 0n;
        message.updatedAt = 0n;
        message.transactionTime = 0n;
        message.height = 0n;
        if (value !== undefined)
            reflectionMergePartial<CreateRFQRequestType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateRFQRequestType): CreateRFQRequestType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rfq_id */ 1:
                    message.rfqId = reader.uint64().toBigInt();
                    break;
                case /* string market_id */ 2:
                    message.marketId = reader.string();
                    break;
                case /* string direction */ 3:
                    message.direction = reader.string();
                    break;
                case /* string margin */ 4:
                    message.margin = reader.string();
                    break;
                case /* string quantity */ 5:
                    message.quantity = reader.string();
                    break;
                case /* string worst_price */ 6:
                    message.worstPrice = reader.string();
                    break;
                case /* uint64 expiry */ 7:
                    message.expiry = reader.uint64().toBigInt();
                    break;
                case /* string status */ 8:
                    message.status = reader.string();
                    break;
                case /* sint64 created_at */ 9:
                    message.createdAt = reader.sint64().toBigInt();
                    break;
                case /* sint64 updated_at */ 10:
                    message.updatedAt = reader.sint64().toBigInt();
                    break;
                case /* uint64 transaction_time */ 11:
                    message.transactionTime = reader.uint64().toBigInt();
                    break;
                case /* uint64 height */ 12:
                    message.height = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateRFQRequestType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rfq_id = 1; */
        if (message.rfqId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rfqId);
        /* string market_id = 2; */
        if (message.marketId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.marketId);
        /* string direction = 3; */
        if (message.direction !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.direction);
        /* string margin = 4; */
        if (message.margin !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.margin);
        /* string quantity = 5; */
        if (message.quantity !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.quantity);
        /* string worst_price = 6; */
        if (message.worstPrice !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.worstPrice);
        /* uint64 expiry = 7; */
        if (message.expiry !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.expiry);
        /* string status = 8; */
        if (message.status !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.status);
        /* sint64 created_at = 9; */
        if (message.createdAt !== 0n)
            writer.tag(9, WireType.Varint).sint64(message.createdAt);
        /* sint64 updated_at = 10; */
        if (message.updatedAt !== 0n)
            writer.tag(10, WireType.Varint).sint64(message.updatedAt);
        /* uint64 transaction_time = 11; */
        if (message.transactionTime !== 0n)
            writer.tag(11, WireType.Varint).uint64(message.transactionTime);
        /* uint64 height = 12; */
        if (message.height !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.CreateRFQRequestType
 */
export const CreateRFQRequestType = new CreateRFQRequestType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakerStreamResponse$Type extends MessageType<TakerStreamResponse> {
    constructor() {
        super("injective_rfqrpc.TakerStreamResponse", [
            { no: 1, name: "message_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quote", kind: "message", T: () => RFQQuoteType },
            { no: 3, name: "request_ack", kind: "message", T: () => StreamAck },
            { no: 4, name: "error", kind: "message", T: () => StreamError }
        ]);
    }
    create(value?: PartialMessage<TakerStreamResponse>): TakerStreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageType = "";
        if (value !== undefined)
            reflectionMergePartial<TakerStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakerStreamResponse): TakerStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_type */ 1:
                    message.messageType = reader.string();
                    break;
                case /* injective_rfqrpc.RFQQuoteType quote */ 2:
                    message.quote = RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options, message.quote);
                    break;
                case /* injective_rfqrpc.StreamAck request_ack */ 3:
                    message.requestAck = StreamAck.internalBinaryRead(reader, reader.uint32(), options, message.requestAck);
                    break;
                case /* injective_rfqrpc.StreamError error */ 4:
                    message.error = StreamError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakerStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_type = 1; */
        if (message.messageType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageType);
        /* injective_rfqrpc.RFQQuoteType quote = 2; */
        if (message.quote)
            RFQQuoteType.internalBinaryWrite(message.quote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective_rfqrpc.StreamAck request_ack = 3; */
        if (message.requestAck)
            StreamAck.internalBinaryWrite(message.requestAck, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective_rfqrpc.StreamError error = 4; */
        if (message.error)
            StreamError.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.TakerStreamResponse
 */
export const TakerStreamResponse = new TakerStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamAck$Type extends MessageType<StreamAck> {
    constructor() {
        super("injective_rfqrpc.StreamAck", [
            { no: 1, name: "rfq_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamAck>): StreamAck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rfqId = 0n;
        message.status = "";
        if (value !== undefined)
            reflectionMergePartial<StreamAck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamAck): StreamAck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rfq_id */ 1:
                    message.rfqId = reader.uint64().toBigInt();
                    break;
                case /* string status */ 2:
                    message.status = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamAck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rfq_id = 1; */
        if (message.rfqId !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.rfqId);
        /* string status = 2; */
        if (message.status !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.StreamAck
 */
export const StreamAck = new StreamAck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StreamError$Type extends MessageType<StreamError> {
    constructor() {
        super("injective_rfqrpc.StreamError", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message_", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StreamError>): StreamError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<StreamError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StreamError): StreamError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string message_ */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StreamError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string message_ = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.StreamError
 */
export const StreamError = new StreamError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakerStreamStreamingRequest$Type extends MessageType<MakerStreamStreamingRequest> {
    constructor() {
        super("injective_rfqrpc.MakerStreamStreamingRequest", [
            { no: 1, name: "message_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quote", kind: "message", T: () => RFQQuoteType }
        ]);
    }
    create(value?: PartialMessage<MakerStreamStreamingRequest>): MakerStreamStreamingRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageType = "";
        if (value !== undefined)
            reflectionMergePartial<MakerStreamStreamingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakerStreamStreamingRequest): MakerStreamStreamingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_type */ 1:
                    message.messageType = reader.string();
                    break;
                case /* injective_rfqrpc.RFQQuoteType quote */ 2:
                    message.quote = RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options, message.quote);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakerStreamStreamingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_type = 1; */
        if (message.messageType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageType);
        /* injective_rfqrpc.RFQQuoteType quote = 2; */
        if (message.quote)
            RFQQuoteType.internalBinaryWrite(message.quote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.MakerStreamStreamingRequest
 */
export const MakerStreamStreamingRequest = new MakerStreamStreamingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MakerStreamResponse$Type extends MessageType<MakerStreamResponse> {
    constructor() {
        super("injective_rfqrpc.MakerStreamResponse", [
            { no: 1, name: "message_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "request", kind: "message", T: () => RFQRequestType },
            { no: 3, name: "quote_ack", kind: "message", T: () => StreamAck },
            { no: 4, name: "error", kind: "message", T: () => StreamError }
        ]);
    }
    create(value?: PartialMessage<MakerStreamResponse>): MakerStreamResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.messageType = "";
        if (value !== undefined)
            reflectionMergePartial<MakerStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MakerStreamResponse): MakerStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_type */ 1:
                    message.messageType = reader.string();
                    break;
                case /* injective_rfqrpc.RFQRequestType request */ 2:
                    message.request = RFQRequestType.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* injective_rfqrpc.StreamAck quote_ack */ 3:
                    message.quoteAck = StreamAck.internalBinaryRead(reader, reader.uint32(), options, message.quoteAck);
                    break;
                case /* injective_rfqrpc.StreamError error */ 4:
                    message.error = StreamError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MakerStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_type = 1; */
        if (message.messageType !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageType);
        /* injective_rfqrpc.RFQRequestType request = 2; */
        if (message.request)
            RFQRequestType.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* injective_rfqrpc.StreamAck quote_ack = 3; */
        if (message.quoteAck)
            StreamAck.internalBinaryWrite(message.quoteAck, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* injective_rfqrpc.StreamError error = 4; */
        if (message.error)
            StreamError.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective_rfqrpc.MakerStreamResponse
 */
export const MakerStreamResponse = new MakerStreamResponse$Type();
/**
 * @generated ServiceType for protobuf service injective_rfqrpc.InjectiveRFQRPC
 */
export const InjectiveRFQRPC = new ServiceType("injective_rfqrpc.InjectiveRFQRPC", [
    { name: "Request", options: {}, I: RequestRequest, O: RequestResponse },
    { name: "StreamRequest", serverStreaming: true, options: {}, I: StreamRequestRequest, O: StreamRequestResponse },
    { name: "Quote", options: {}, I: QuoteRequest, O: QuoteResponse },
    { name: "StreamQuote", serverStreaming: true, options: {}, I: StreamQuoteRequest, O: StreamQuoteResponse },
    { name: "GetOpenRequests", options: {}, I: GetOpenRequestsRequest, O: GetOpenRequestsResponse },
    { name: "GetPendingQuotes", options: {}, I: GetPendingQuotesRequest, O: GetPendingQuotesResponse },
    { name: "ListSettlement", options: {}, I: ListSettlementRequest, O: ListSettlementResponse },
    { name: "StreamSettlement", serverStreaming: true, options: {}, I: StreamSettlementRequest, O: StreamSettlementResponse },
    { name: "TakerStream", serverStreaming: true, clientStreaming: true, options: {}, I: TakerStreamStreamingRequest, O: TakerStreamResponse },
    { name: "MakerStream", serverStreaming: true, clientStreaming: true, options: {}, I: MakerStreamStreamingRequest, O: MakerStreamResponse }
]);
