import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
class RequestRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.RequestRequest", [
      { no: 1, name: "request", kind: "message", T: () => RFQRequestType }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_rfqrpc.RFQRequestType request */
        1:
          message.request = RFQRequestType.internalBinaryRead(reader, reader.uint32(), options, message.request);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.request)
      RFQRequestType.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestRequest = new RequestRequest$Type();
class RFQRequestType$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.RFQRequestType", [
      {
        no: 1,
        name: "rfq_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "worst_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "request_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "expiry",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 9,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "transaction_time",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rfqId = 0n;
    message.marketId = "";
    message.direction = "";
    message.margin = "";
    message.quantity = "";
    message.worstPrice = "";
    message.requestAddress = "";
    message.expiry = 0n;
    message.status = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.transactionTime = 0n;
    message.height = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 rfq_id */
        1:
          message.rfqId = reader.uint64().toBigInt();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string margin */
        4:
          message.margin = reader.string();
          break;
        case /* string quantity */
        5:
          message.quantity = reader.string();
          break;
        case /* string worst_price */
        6:
          message.worstPrice = reader.string();
          break;
        case /* string request_address */
        7:
          message.requestAddress = reader.string();
          break;
        case /* uint64 expiry */
        8:
          message.expiry = reader.uint64().toBigInt();
          break;
        case /* string status */
        9:
          message.status = reader.string();
          break;
        case /* sint64 created_at */
        10:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        11:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* uint64 transaction_time */
        12:
          message.transactionTime = reader.uint64().toBigInt();
          break;
        case /* uint64 height */
        13:
          message.height = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rfqId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.rfqId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.margin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.margin);
    if (message.quantity !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.quantity);
    if (message.worstPrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.worstPrice);
    if (message.requestAddress !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.requestAddress);
    if (message.expiry !== 0n)
      writer.tag(8, WireType.Varint).uint64(message.expiry);
    if (message.status !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.status);
    if (message.createdAt !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(11, WireType.Varint).sint64(message.updatedAt);
    if (message.transactionTime !== 0n)
      writer.tag(12, WireType.Varint).uint64(message.transactionTime);
    if (message.height !== 0n)
      writer.tag(13, WireType.Varint).uint64(message.height);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RFQRequestType = new RFQRequestType$Type();
class RequestResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.RequestResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string status */
        1:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RequestResponse = new RequestResponse$Type();
class StreamRequestRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.StreamRequestRequest", [
      {
        no: 1,
        name: "market_ids",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.marketIds = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string market_ids */
        1:
          message.marketIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.marketIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.marketIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamRequestRequest = new StreamRequestRequest$Type();
class StreamRequestResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.StreamRequestResponse", [
      { no: 1, name: "request", kind: "message", T: () => RFQRequestType },
      {
        no: 2,
        name: "stream_operation",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.streamOperation = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_rfqrpc.RFQRequestType request */
        1:
          message.request = RFQRequestType.internalBinaryRead(reader, reader.uint32(), options, message.request);
          break;
        case /* string stream_operation */
        2:
          message.streamOperation = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.request)
      RFQRequestType.internalBinaryWrite(message.request, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.streamOperation !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.streamOperation);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamRequestResponse = new StreamRequestResponse$Type();
class QuoteRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.QuoteRequest", [
      { no: 1, name: "quote", kind: "message", T: () => RFQQuoteType }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_rfqrpc.RFQQuoteType quote */
        1:
          message.quote = RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options, message.quote);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.quote)
      RFQQuoteType.internalBinaryWrite(message.quote, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuoteRequest = new QuoteRequest$Type();
class RFQQuoteType$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.RFQQuoteType", [
      {
        no: 1,
        name: "chain_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "contract_address",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "rfq_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 5,
        name: "taker_direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "expiry",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "maker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "taker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 12,
        name: "signature",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 15,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 16,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 17,
        name: "event_time",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 18,
        name: "transaction_time",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.chainId = "";
    message.contractAddress = "";
    message.marketId = "";
    message.rfqId = 0n;
    message.takerDirection = "";
    message.margin = "";
    message.quantity = "";
    message.price = "";
    message.expiry = 0n;
    message.maker = "";
    message.taker = "";
    message.signature = "";
    message.status = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.height = 0n;
    message.eventTime = 0n;
    message.transactionTime = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string chain_id */
        1:
          message.chainId = reader.string();
          break;
        case /* string contract_address */
        2:
          message.contractAddress = reader.string();
          break;
        case /* string market_id */
        3:
          message.marketId = reader.string();
          break;
        case /* uint64 rfq_id */
        4:
          message.rfqId = reader.uint64().toBigInt();
          break;
        case /* string taker_direction */
        5:
          message.takerDirection = reader.string();
          break;
        case /* string margin */
        6:
          message.margin = reader.string();
          break;
        case /* string quantity */
        7:
          message.quantity = reader.string();
          break;
        case /* string price */
        8:
          message.price = reader.string();
          break;
        case /* uint64 expiry */
        9:
          message.expiry = reader.uint64().toBigInt();
          break;
        case /* string maker */
        10:
          message.maker = reader.string();
          break;
        case /* string taker */
        11:
          message.taker = reader.string();
          break;
        case /* string signature */
        12:
          message.signature = reader.string();
          break;
        case /* string status */
        13:
          message.status = reader.string();
          break;
        case /* sint64 created_at */
        14:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        15:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* uint64 height */
        16:
          message.height = reader.uint64().toBigInt();
          break;
        case /* uint64 event_time */
        17:
          message.eventTime = reader.uint64().toBigInt();
          break;
        case /* uint64 transaction_time */
        18:
          message.transactionTime = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.chainId !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.chainId);
    if (message.contractAddress !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.contractAddress);
    if (message.marketId !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.marketId);
    if (message.rfqId !== 0n)
      writer.tag(4, WireType.Varint).uint64(message.rfqId);
    if (message.takerDirection !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.takerDirection);
    if (message.margin !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.margin);
    if (message.quantity !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.quantity);
    if (message.price !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.price);
    if (message.expiry !== 0n)
      writer.tag(9, WireType.Varint).uint64(message.expiry);
    if (message.maker !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.maker);
    if (message.taker !== "")
      writer.tag(11, WireType.LengthDelimited).string(message.taker);
    if (message.signature !== "")
      writer.tag(12, WireType.LengthDelimited).string(message.signature);
    if (message.status !== "")
      writer.tag(13, WireType.LengthDelimited).string(message.status);
    if (message.createdAt !== 0n)
      writer.tag(14, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(15, WireType.Varint).sint64(message.updatedAt);
    if (message.height !== 0n)
      writer.tag(16, WireType.Varint).uint64(message.height);
    if (message.eventTime !== 0n)
      writer.tag(17, WireType.Varint).uint64(message.eventTime);
    if (message.transactionTime !== 0n)
      writer.tag(18, WireType.Varint).uint64(message.transactionTime);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RFQQuoteType = new RFQQuoteType$Type();
class QuoteResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.QuoteResponse", [
      {
        no: 1,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string status */
        1:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.status !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const QuoteResponse = new QuoteResponse$Type();
class StreamQuoteRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.StreamQuoteRequest", [
      {
        no: 1,
        name: "addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.addresses = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string addresses */
        1:
          message.addresses.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamQuoteRequest = new StreamQuoteRequest$Type();
class StreamQuoteResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.StreamQuoteResponse", [
      { no: 1, name: "quote", kind: "message", T: () => RFQQuoteType },
      {
        no: 2,
        name: "stream_operation",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.streamOperation = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_rfqrpc.RFQQuoteType quote */
        1:
          message.quote = RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options, message.quote);
          break;
        case /* string stream_operation */
        2:
          message.streamOperation = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.quote)
      RFQQuoteType.internalBinaryWrite(message.quote, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.streamOperation !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.streamOperation);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamQuoteResponse = new StreamQuoteResponse$Type();
class GetOpenRequestsRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.GetOpenRequestsRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetOpenRequestsRequest = new GetOpenRequestsRequest$Type();
class GetOpenRequestsResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.GetOpenRequestsResponse", [
      { no: 1, name: "requests", kind: "message", repeat: 2, T: () => RFQRequestType }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.requests = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_rfqrpc.RFQRequestType requests */
        1:
          message.requests.push(RFQRequestType.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.requests.length; i++)
      RFQRequestType.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetOpenRequestsResponse = new GetOpenRequestsResponse$Type();
class GetPendingQuotesRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.GetPendingQuotesRequest", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetPendingQuotesRequest = new GetPendingQuotesRequest$Type();
class GetPendingQuotesResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.GetPendingQuotesResponse", [
      { no: 1, name: "quotes", kind: "message", repeat: 2, T: () => RFQQuoteType }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.quotes = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_rfqrpc.RFQQuoteType quotes */
        1:
          message.quotes.push(RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.quotes.length; i++)
      RFQQuoteType.internalBinaryWrite(message.quotes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const GetPendingQuotesResponse = new GetPendingQuotesResponse$Type();
class ListSettlementRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.ListSettlementRequest", [
      {
        no: 1,
        name: "addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "skip",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 3,
        name: "limit",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.addresses = [];
    message.skip = 0n;
    message.limit = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string addresses */
        1:
          message.addresses.push(reader.string());
          break;
        case /* sint64 skip */
        2:
          message.skip = reader.sint64().toBigInt();
          break;
        case /* sint64 limit */
        3:
          message.limit = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
    if (message.skip !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.skip);
    if (message.limit !== 0n)
      writer.tag(3, WireType.Varint).sint64(message.limit);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListSettlementRequest = new ListSettlementRequest$Type();
class ListSettlementResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.ListSettlementResponse", [
      { no: 1, name: "settlements", kind: "message", repeat: 2, T: () => RFQSettlementType },
      {
        no: 2,
        name: "total",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.settlements = [];
    message.total = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated injective_rfqrpc.RFQSettlementType settlements */
        1:
          message.settlements.push(RFQSettlementType.internalBinaryRead(reader, reader.uint32(), options));
          break;
        case /* sint64 total */
        2:
          message.total = reader.sint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.settlements.length; i++)
      RFQSettlementType.internalBinaryWrite(message.settlements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.total !== 0n)
      writer.tag(2, WireType.Varint).sint64(message.total);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const ListSettlementResponse = new ListSettlementResponse$Type();
class RFQSettlementType$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.RFQSettlementType", [
      {
        no: 1,
        name: "rfq_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "taker",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "worst_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 8, name: "unfilled_action", kind: "message", T: () => RFQSettlementUnfilledActionType },
      {
        no: 9,
        name: "fallback_quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 10,
        name: "fallback_margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "transaction_time",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 13,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 14,
        name: "event_time",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 15,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rfqId = 0n;
    message.marketId = "";
    message.taker = "";
    message.direction = "";
    message.margin = "";
    message.quantity = "";
    message.worstPrice = "";
    message.fallbackQuantity = "";
    message.fallbackMargin = "";
    message.transactionTime = 0n;
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.eventTime = 0n;
    message.height = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 rfq_id */
        1:
          message.rfqId = reader.uint64().toBigInt();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string taker */
        3:
          message.taker = reader.string();
          break;
        case /* string direction */
        4:
          message.direction = reader.string();
          break;
        case /* string margin */
        5:
          message.margin = reader.string();
          break;
        case /* string quantity */
        6:
          message.quantity = reader.string();
          break;
        case /* string worst_price */
        7:
          message.worstPrice = reader.string();
          break;
        case /* injective_rfqrpc.RFQSettlementUnfilledActionType unfilled_action */
        8:
          message.unfilledAction = RFQSettlementUnfilledActionType.internalBinaryRead(reader, reader.uint32(), options, message.unfilledAction);
          break;
        case /* string fallback_quantity */
        9:
          message.fallbackQuantity = reader.string();
          break;
        case /* string fallback_margin */
        10:
          message.fallbackMargin = reader.string();
          break;
        case /* uint64 transaction_time */
        11:
          message.transactionTime = reader.uint64().toBigInt();
          break;
        case /* sint64 created_at */
        12:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        13:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* uint64 event_time */
        14:
          message.eventTime = reader.uint64().toBigInt();
          break;
        case /* uint64 height */
        15:
          message.height = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rfqId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.rfqId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.taker !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.taker);
    if (message.direction !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.direction);
    if (message.margin !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.margin);
    if (message.quantity !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.quantity);
    if (message.worstPrice !== "")
      writer.tag(7, WireType.LengthDelimited).string(message.worstPrice);
    if (message.unfilledAction)
      RFQSettlementUnfilledActionType.internalBinaryWrite(message.unfilledAction, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
    if (message.fallbackQuantity !== "")
      writer.tag(9, WireType.LengthDelimited).string(message.fallbackQuantity);
    if (message.fallbackMargin !== "")
      writer.tag(10, WireType.LengthDelimited).string(message.fallbackMargin);
    if (message.transactionTime !== 0n)
      writer.tag(11, WireType.Varint).uint64(message.transactionTime);
    if (message.createdAt !== 0n)
      writer.tag(12, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(13, WireType.Varint).sint64(message.updatedAt);
    if (message.eventTime !== 0n)
      writer.tag(14, WireType.Varint).uint64(message.eventTime);
    if (message.height !== 0n)
      writer.tag(15, WireType.Varint).uint64(message.height);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RFQSettlementType = new RFQSettlementType$Type();
class RFQSettlementUnfilledActionType$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.RFQSettlementUnfilledActionType", [
      { no: 1, name: "limit", kind: "message", T: () => RFQSettlementLimitActionType },
      { no: 2, name: "market", kind: "message", T: () => RFQSettlementMarketActionType }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_rfqrpc.RFQSettlementLimitActionType limit */
        1:
          message.limit = RFQSettlementLimitActionType.internalBinaryRead(reader, reader.uint32(), options, message.limit);
          break;
        case /* injective_rfqrpc.RFQSettlementMarketActionType market */
        2:
          message.market = RFQSettlementMarketActionType.internalBinaryRead(reader, reader.uint32(), options, message.market);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.limit)
      RFQSettlementLimitActionType.internalBinaryWrite(message.limit, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.market)
      RFQSettlementMarketActionType.internalBinaryWrite(message.market, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RFQSettlementUnfilledActionType = new RFQSettlementUnfilledActionType$Type();
class RFQSettlementLimitActionType$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.RFQSettlementLimitActionType", [
      {
        no: 1,
        name: "price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.price = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string price */
        1:
          message.price = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.price !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.price);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RFQSettlementLimitActionType = new RFQSettlementLimitActionType$Type();
class RFQSettlementMarketActionType$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.RFQSettlementMarketActionType", []);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const RFQSettlementMarketActionType = new RFQSettlementMarketActionType$Type();
class StreamSettlementRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.StreamSettlementRequest", [
      {
        no: 1,
        name: "addresses",
        kind: "scalar",
        repeat: 2,
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.addresses = [];
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string addresses */
        1:
          message.addresses.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    for (let i = 0; i < message.addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamSettlementRequest = new StreamSettlementRequest$Type();
class StreamSettlementResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.StreamSettlementResponse", [
      { no: 1, name: "settlement", kind: "message", T: () => RFQSettlementType },
      {
        no: 2,
        name: "stream_operation",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.streamOperation = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* injective_rfqrpc.RFQSettlementType settlement */
        1:
          message.settlement = RFQSettlementType.internalBinaryRead(reader, reader.uint32(), options, message.settlement);
          break;
        case /* string stream_operation */
        2:
          message.streamOperation = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.settlement)
      RFQSettlementType.internalBinaryWrite(message.settlement, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    if (message.streamOperation !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.streamOperation);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamSettlementResponse = new StreamSettlementResponse$Type();
class TakerStreamStreamingRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.TakerStreamStreamingRequest", [
      {
        no: 1,
        name: "message_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "request", kind: "message", T: () => CreateRFQRequestType }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.messageType = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message_type */
        1:
          message.messageType = reader.string();
          break;
        case /* injective_rfqrpc.CreateRFQRequestType request */
        2:
          message.request = CreateRFQRequestType.internalBinaryRead(reader, reader.uint32(), options, message.request);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.messageType !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.messageType);
    if (message.request)
      CreateRFQRequestType.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TakerStreamStreamingRequest = new TakerStreamStreamingRequest$Type();
class CreateRFQRequestType$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.CreateRFQRequestType", [
      {
        no: 1,
        name: "rfq_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "market_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "direction",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "margin",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "quantity",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "worst_price",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "expiry",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 8,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 9,
        name: "created_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 10,
        name: "updated_at",
        kind: "scalar",
        T: 18,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 11,
        name: "transaction_time",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 12,
        name: "height",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rfqId = 0n;
    message.marketId = "";
    message.direction = "";
    message.margin = "";
    message.quantity = "";
    message.worstPrice = "";
    message.expiry = 0n;
    message.status = "";
    message.createdAt = 0n;
    message.updatedAt = 0n;
    message.transactionTime = 0n;
    message.height = 0n;
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 rfq_id */
        1:
          message.rfqId = reader.uint64().toBigInt();
          break;
        case /* string market_id */
        2:
          message.marketId = reader.string();
          break;
        case /* string direction */
        3:
          message.direction = reader.string();
          break;
        case /* string margin */
        4:
          message.margin = reader.string();
          break;
        case /* string quantity */
        5:
          message.quantity = reader.string();
          break;
        case /* string worst_price */
        6:
          message.worstPrice = reader.string();
          break;
        case /* uint64 expiry */
        7:
          message.expiry = reader.uint64().toBigInt();
          break;
        case /* string status */
        8:
          message.status = reader.string();
          break;
        case /* sint64 created_at */
        9:
          message.createdAt = reader.sint64().toBigInt();
          break;
        case /* sint64 updated_at */
        10:
          message.updatedAt = reader.sint64().toBigInt();
          break;
        case /* uint64 transaction_time */
        11:
          message.transactionTime = reader.uint64().toBigInt();
          break;
        case /* uint64 height */
        12:
          message.height = reader.uint64().toBigInt();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rfqId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.rfqId);
    if (message.marketId !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.marketId);
    if (message.direction !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.direction);
    if (message.margin !== "")
      writer.tag(4, WireType.LengthDelimited).string(message.margin);
    if (message.quantity !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.quantity);
    if (message.worstPrice !== "")
      writer.tag(6, WireType.LengthDelimited).string(message.worstPrice);
    if (message.expiry !== 0n)
      writer.tag(7, WireType.Varint).uint64(message.expiry);
    if (message.status !== "")
      writer.tag(8, WireType.LengthDelimited).string(message.status);
    if (message.createdAt !== 0n)
      writer.tag(9, WireType.Varint).sint64(message.createdAt);
    if (message.updatedAt !== 0n)
      writer.tag(10, WireType.Varint).sint64(message.updatedAt);
    if (message.transactionTime !== 0n)
      writer.tag(11, WireType.Varint).uint64(message.transactionTime);
    if (message.height !== 0n)
      writer.tag(12, WireType.Varint).uint64(message.height);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const CreateRFQRequestType = new CreateRFQRequestType$Type();
class TakerStreamResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.TakerStreamResponse", [
      {
        no: 1,
        name: "message_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "quote", kind: "message", T: () => RFQQuoteType },
      { no: 3, name: "request_ack", kind: "message", T: () => StreamAck },
      { no: 4, name: "error", kind: "message", T: () => StreamError }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.messageType = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message_type */
        1:
          message.messageType = reader.string();
          break;
        case /* injective_rfqrpc.RFQQuoteType quote */
        2:
          message.quote = RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options, message.quote);
          break;
        case /* injective_rfqrpc.StreamAck request_ack */
        3:
          message.requestAck = StreamAck.internalBinaryRead(reader, reader.uint32(), options, message.requestAck);
          break;
        case /* injective_rfqrpc.StreamError error */
        4:
          message.error = StreamError.internalBinaryRead(reader, reader.uint32(), options, message.error);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.messageType !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.messageType);
    if (message.quote)
      RFQQuoteType.internalBinaryWrite(message.quote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.requestAck)
      StreamAck.internalBinaryWrite(message.requestAck, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.error)
      StreamError.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const TakerStreamResponse = new TakerStreamResponse$Type();
class StreamAck$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.StreamAck", [
      {
        no: 1,
        name: "rfq_id",
        kind: "scalar",
        T: 4,
        L: 0
        /*LongType.BIGINT*/
      },
      {
        no: 2,
        name: "status",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.rfqId = 0n;
    message.status = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* uint64 rfq_id */
        1:
          message.rfqId = reader.uint64().toBigInt();
          break;
        case /* string status */
        2:
          message.status = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.rfqId !== 0n)
      writer.tag(1, WireType.Varint).uint64(message.rfqId);
    if (message.status !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.status);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamAck = new StreamAck$Type();
class StreamError$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.StreamError", [
      {
        no: 1,
        name: "code",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "message_",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.code = "";
    message.message = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string code */
        1:
          message.code = reader.string();
          break;
        case /* string message_ */
        2:
          message.message = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.code !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.code);
    if (message.message !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.message);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const StreamError = new StreamError$Type();
class MakerStreamStreamingRequest$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.MakerStreamStreamingRequest", [
      {
        no: 1,
        name: "message_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "quote", kind: "message", T: () => RFQQuoteType }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.messageType = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message_type */
        1:
          message.messageType = reader.string();
          break;
        case /* injective_rfqrpc.RFQQuoteType quote */
        2:
          message.quote = RFQQuoteType.internalBinaryRead(reader, reader.uint32(), options, message.quote);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.messageType !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.messageType);
    if (message.quote)
      RFQQuoteType.internalBinaryWrite(message.quote, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MakerStreamStreamingRequest = new MakerStreamStreamingRequest$Type();
class MakerStreamResponse$Type extends MessageType {
  constructor() {
    super("injective_rfqrpc.MakerStreamResponse", [
      {
        no: 1,
        name: "message_type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "request", kind: "message", T: () => RFQRequestType },
      { no: 3, name: "quote_ack", kind: "message", T: () => StreamAck },
      { no: 4, name: "error", kind: "message", T: () => StreamError }
    ]);
  }
  create(value) {
    const message = globalThis.Object.create(this.messagePrototype);
    message.messageType = "";
    if (value !== void 0)
      reflectionMergePartial(this, message, value);
    return message;
  }
  internalBinaryRead(reader, length, options, target) {
    let message = target ?? this.create(), end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string message_type */
        1:
          message.messageType = reader.string();
          break;
        case /* injective_rfqrpc.RFQRequestType request */
        2:
          message.request = RFQRequestType.internalBinaryRead(reader, reader.uint32(), options, message.request);
          break;
        case /* injective_rfqrpc.StreamAck quote_ack */
        3:
          message.quoteAck = StreamAck.internalBinaryRead(reader, reader.uint32(), options, message.quoteAck);
          break;
        case /* injective_rfqrpc.StreamError error */
        4:
          message.error = StreamError.internalBinaryRead(reader, reader.uint32(), options, message.error);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message, writer, options) {
    if (message.messageType !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.messageType);
    if (message.request)
      RFQRequestType.internalBinaryWrite(message.request, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
    if (message.quoteAck)
      StreamAck.internalBinaryWrite(message.quoteAck, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
    if (message.error)
      StreamError.internalBinaryWrite(message.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
const MakerStreamResponse = new MakerStreamResponse$Type();
const InjectiveRFQRPC = new ServiceType("injective_rfqrpc.InjectiveRFQRPC", [
  { name: "Request", options: {}, I: RequestRequest, O: RequestResponse },
  { name: "StreamRequest", serverStreaming: true, options: {}, I: StreamRequestRequest, O: StreamRequestResponse },
  { name: "Quote", options: {}, I: QuoteRequest, O: QuoteResponse },
  { name: "StreamQuote", serverStreaming: true, options: {}, I: StreamQuoteRequest, O: StreamQuoteResponse },
  { name: "GetOpenRequests", options: {}, I: GetOpenRequestsRequest, O: GetOpenRequestsResponse },
  { name: "GetPendingQuotes", options: {}, I: GetPendingQuotesRequest, O: GetPendingQuotesResponse },
  { name: "ListSettlement", options: {}, I: ListSettlementRequest, O: ListSettlementResponse },
  { name: "StreamSettlement", serverStreaming: true, options: {}, I: StreamSettlementRequest, O: StreamSettlementResponse },
  { name: "TakerStream", serverStreaming: true, clientStreaming: true, options: {}, I: TakerStreamStreamingRequest, O: TakerStreamResponse },
  { name: "MakerStream", serverStreaming: true, clientStreaming: true, options: {}, I: MakerStreamStreamingRequest, O: MakerStreamResponse }
]);
export {
  CreateRFQRequestType,
  GetOpenRequestsRequest,
  GetOpenRequestsResponse,
  GetPendingQuotesRequest,
  GetPendingQuotesResponse,
  InjectiveRFQRPC,
  ListSettlementRequest,
  ListSettlementResponse,
  MakerStreamResponse,
  MakerStreamStreamingRequest,
  QuoteRequest,
  QuoteResponse,
  RFQQuoteType,
  RFQRequestType,
  RFQSettlementLimitActionType,
  RFQSettlementMarketActionType,
  RFQSettlementType,
  RFQSettlementUnfilledActionType,
  RequestRequest,
  RequestResponse,
  StreamAck,
  StreamError,
  StreamQuoteRequest,
  StreamQuoteResponse,
  StreamRequestRequest,
  StreamRequestResponse,
  StreamSettlementRequest,
  StreamSettlementResponse,
  TakerStreamResponse,
  TakerStreamStreamingRequest
};
