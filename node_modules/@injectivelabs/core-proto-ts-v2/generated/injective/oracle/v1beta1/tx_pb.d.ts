// @generated by protobuf-ts 2.11.1 with parameter add_pb_suffix
// @generated from protobuf file "injective/oracle/v1beta1/tx.proto" (package "injective.oracle.v1beta1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Params } from "./oracle_pb";
import { ChainlinkReport } from "./oracle_pb";
import { PriceAttestation } from "./oracle_pb";
import { AssetPair } from "./oracle_pb";
/**
 * MsgRelayProviderPrice defines a SDK message for setting a price through the
 * provider oracle.
 *
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayProviderPrices
 */
export interface MsgRelayProviderPrices {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: string provider = 2
     */
    provider: string;
    /**
     * @generated from protobuf field: repeated string symbols = 3
     */
    symbols: string[];
    /**
     * @generated from protobuf field: repeated string prices = 4
     */
    prices: string[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayProviderPricesResponse
 */
export interface MsgRelayProviderPricesResponse {
}
/**
 * MsgRelayPriceFeedPrice defines a SDK message for setting a price through the
 * pricefeed oracle.
 *
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayPriceFeedPrice
 */
export interface MsgRelayPriceFeedPrice {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated string base = 2
     */
    base: string[];
    /**
     * @generated from protobuf field: repeated string quote = 3
     */
    quote: string[];
    /**
     * price defines the price of the oracle base and quote
     *
     * @generated from protobuf field: repeated string price = 4
     */
    price: string[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayPriceFeedPriceResponse
 */
export interface MsgRelayPriceFeedPriceResponse {
}
/**
 * MsgRelayCoinbaseMessages defines a SDK message for relaying price messages
 * from Coinbase API.
 *
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayCoinbaseMessages
 */
export interface MsgRelayCoinbaseMessages {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated bytes messages = 2
     */
    messages: Uint8Array[];
    /**
     * @generated from protobuf field: repeated bytes signatures = 3
     */
    signatures: Uint8Array[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayCoinbaseMessagesResponse
 */
export interface MsgRelayCoinbaseMessagesResponse {
}
/**
 * MsgRelayStorkPrices defines a SDK message for relaying price message
 * from Stork API.
 *
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayStorkPrices
 */
export interface MsgRelayStorkPrices {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.AssetPair asset_pairs = 2
     */
    assetPairs: AssetPair[];
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayStorkPricesResponse
 */
export interface MsgRelayStorkPricesResponse {
}
/**
 * MsgRelayPythPrices defines a SDK message for updating Pyth prices
 *
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayPythPrices
 */
export interface MsgRelayPythPrices {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.PriceAttestation price_attestations = 2
     */
    priceAttestations: PriceAttestation[];
}
/**
 * MsgRelayPythPricesResponse defines the Msg/RelayPythPrices response type.
 *
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayPythPricesResponse
 */
export interface MsgRelayPythPricesResponse {
}
/**
 * MsgRelayChainlinkPrices defines a SDK message for updating Chainlink Data
 * Streams prices
 *
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayChainlinkPrices
 */
export interface MsgRelayChainlinkPrices {
    /**
     * @generated from protobuf field: string sender = 1
     */
    sender: string;
    /**
     * @generated from protobuf field: repeated injective.oracle.v1beta1.ChainlinkReport reports = 2
     */
    reports: ChainlinkReport[];
}
/**
 * MsgRelayChainlinkPricesResponse defines the Msg/RelayChainlinkPrices response
 * type.
 *
 * @generated from protobuf message injective.oracle.v1beta1.MsgRelayChainlinkPricesResponse
 */
export interface MsgRelayChainlinkPricesResponse {
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.MsgUpdateParams
 */
export interface MsgUpdateParams {
    /**
     * authority is the address of the governance account.
     *
     * @generated from protobuf field: string authority = 1
     */
    authority: string;
    /**
     * params defines the oracle parameters to update.
     *
     * NOTE: All parameters must be supplied.
     *
     * @generated from protobuf field: injective.oracle.v1beta1.Params params = 2
     */
    params?: Params;
}
/**
 * @generated from protobuf message injective.oracle.v1beta1.MsgUpdateParamsResponse
 */
export interface MsgUpdateParamsResponse {
}
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayProviderPrices$Type extends MessageType<MsgRelayProviderPrices> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayProviderPrices", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "symbols", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "prices", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "oracle/MsgRelayProviderPrices", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgRelayProviderPrices>): MsgRelayProviderPrices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.provider = "";
        message.symbols = [];
        message.prices = [];
        if (value !== undefined)
            reflectionMergePartial<MsgRelayProviderPrices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayProviderPrices): MsgRelayProviderPrices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* string provider */ 2:
                    message.provider = reader.string();
                    break;
                case /* repeated string symbols */ 3:
                    message.symbols.push(reader.string());
                    break;
                case /* repeated string prices */ 4:
                    message.prices.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayProviderPrices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* string provider = 2; */
        if (message.provider !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.provider);
        /* repeated string symbols = 3; */
        for (let i = 0; i < message.symbols.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.symbols[i]);
        /* repeated string prices = 4; */
        for (let i = 0; i < message.prices.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.prices[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayProviderPrices
 */
export const MsgRelayProviderPrices = new MsgRelayProviderPrices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayProviderPricesResponse$Type extends MessageType<MsgRelayProviderPricesResponse> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayProviderPricesResponse", []);
    }
    create(value?: PartialMessage<MsgRelayProviderPricesResponse>): MsgRelayProviderPricesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRelayProviderPricesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayProviderPricesResponse): MsgRelayProviderPricesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayProviderPricesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayProviderPricesResponse
 */
export const MsgRelayProviderPricesResponse = new MsgRelayProviderPricesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayPriceFeedPrice$Type extends MessageType<MsgRelayPriceFeedPrice> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayPriceFeedPrice", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "base", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quote", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "price", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/, options: { "gogoproto.nullable": false, "gogoproto.customtype": "cosmossdk.io/math.LegacyDec" } }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "oracle/MsgRelayPriceFeedPrice", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgRelayPriceFeedPrice>): MsgRelayPriceFeedPrice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.base = [];
        message.quote = [];
        message.price = [];
        if (value !== undefined)
            reflectionMergePartial<MsgRelayPriceFeedPrice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayPriceFeedPrice): MsgRelayPriceFeedPrice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated string base */ 2:
                    message.base.push(reader.string());
                    break;
                case /* repeated string quote */ 3:
                    message.quote.push(reader.string());
                    break;
                case /* repeated string price */ 4:
                    message.price.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayPriceFeedPrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated string base = 2; */
        for (let i = 0; i < message.base.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.base[i]);
        /* repeated string quote = 3; */
        for (let i = 0; i < message.quote.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.quote[i]);
        /* repeated string price = 4; */
        for (let i = 0; i < message.price.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.price[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayPriceFeedPrice
 */
export const MsgRelayPriceFeedPrice = new MsgRelayPriceFeedPrice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayPriceFeedPriceResponse$Type extends MessageType<MsgRelayPriceFeedPriceResponse> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayPriceFeedPriceResponse", []);
    }
    create(value?: PartialMessage<MsgRelayPriceFeedPriceResponse>): MsgRelayPriceFeedPriceResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRelayPriceFeedPriceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayPriceFeedPriceResponse): MsgRelayPriceFeedPriceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayPriceFeedPriceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayPriceFeedPriceResponse
 */
export const MsgRelayPriceFeedPriceResponse = new MsgRelayPriceFeedPriceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayCoinbaseMessages$Type extends MessageType<MsgRelayCoinbaseMessages> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayCoinbaseMessages", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "messages", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "signatures", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "oracle/MsgRelayCoinbaseMessages", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgRelayCoinbaseMessages>): MsgRelayCoinbaseMessages {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.messages = [];
        message.signatures = [];
        if (value !== undefined)
            reflectionMergePartial<MsgRelayCoinbaseMessages>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayCoinbaseMessages): MsgRelayCoinbaseMessages {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated bytes messages */ 2:
                    message.messages.push(reader.bytes());
                    break;
                case /* repeated bytes signatures */ 3:
                    message.signatures.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayCoinbaseMessages, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated bytes messages = 2; */
        for (let i = 0; i < message.messages.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.messages[i]);
        /* repeated bytes signatures = 3; */
        for (let i = 0; i < message.signatures.length; i++)
            writer.tag(3, WireType.LengthDelimited).bytes(message.signatures[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayCoinbaseMessages
 */
export const MsgRelayCoinbaseMessages = new MsgRelayCoinbaseMessages$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayCoinbaseMessagesResponse$Type extends MessageType<MsgRelayCoinbaseMessagesResponse> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayCoinbaseMessagesResponse", []);
    }
    create(value?: PartialMessage<MsgRelayCoinbaseMessagesResponse>): MsgRelayCoinbaseMessagesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRelayCoinbaseMessagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayCoinbaseMessagesResponse): MsgRelayCoinbaseMessagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayCoinbaseMessagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayCoinbaseMessagesResponse
 */
export const MsgRelayCoinbaseMessagesResponse = new MsgRelayCoinbaseMessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayStorkPrices$Type extends MessageType<MsgRelayStorkPrices> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayStorkPrices", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "asset_pairs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AssetPair }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgRelayStorkPrices>): MsgRelayStorkPrices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.assetPairs = [];
        if (value !== undefined)
            reflectionMergePartial<MsgRelayStorkPrices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayStorkPrices): MsgRelayStorkPrices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.oracle.v1beta1.AssetPair asset_pairs */ 2:
                    message.assetPairs.push(AssetPair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayStorkPrices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.oracle.v1beta1.AssetPair asset_pairs = 2; */
        for (let i = 0; i < message.assetPairs.length; i++)
            AssetPair.internalBinaryWrite(message.assetPairs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayStorkPrices
 */
export const MsgRelayStorkPrices = new MsgRelayStorkPrices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayStorkPricesResponse$Type extends MessageType<MsgRelayStorkPricesResponse> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayStorkPricesResponse", []);
    }
    create(value?: PartialMessage<MsgRelayStorkPricesResponse>): MsgRelayStorkPricesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRelayStorkPricesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayStorkPricesResponse): MsgRelayStorkPricesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayStorkPricesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayStorkPricesResponse
 */
export const MsgRelayStorkPricesResponse = new MsgRelayStorkPricesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayPythPrices$Type extends MessageType<MsgRelayPythPrices> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayPythPrices", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "price_attestations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PriceAttestation }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "oracle/MsgRelayPythPrices", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgRelayPythPrices>): MsgRelayPythPrices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.priceAttestations = [];
        if (value !== undefined)
            reflectionMergePartial<MsgRelayPythPrices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayPythPrices): MsgRelayPythPrices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.oracle.v1beta1.PriceAttestation price_attestations */ 2:
                    message.priceAttestations.push(PriceAttestation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayPythPrices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.oracle.v1beta1.PriceAttestation price_attestations = 2; */
        for (let i = 0; i < message.priceAttestations.length; i++)
            PriceAttestation.internalBinaryWrite(message.priceAttestations[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayPythPrices
 */
export const MsgRelayPythPrices = new MsgRelayPythPrices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayPythPricesResponse$Type extends MessageType<MsgRelayPythPricesResponse> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayPythPricesResponse", []);
    }
    create(value?: PartialMessage<MsgRelayPythPricesResponse>): MsgRelayPythPricesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRelayPythPricesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayPythPricesResponse): MsgRelayPythPricesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayPythPricesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayPythPricesResponse
 */
export const MsgRelayPythPricesResponse = new MsgRelayPythPricesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayChainlinkPrices$Type extends MessageType<MsgRelayChainlinkPrices> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayChainlinkPrices", [
            { no: 1, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "reports", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ChainlinkReport }
        ], { "gogoproto.goproto_getters": false, "gogoproto.equal": false, "amino.name": "oracle/MsgRelayChainlinkPrices", "cosmos.msg.v1.signer": ["sender"] });
    }
    create(value?: PartialMessage<MsgRelayChainlinkPrices>): MsgRelayChainlinkPrices {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sender = "";
        message.reports = [];
        if (value !== undefined)
            reflectionMergePartial<MsgRelayChainlinkPrices>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayChainlinkPrices): MsgRelayChainlinkPrices {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sender */ 1:
                    message.sender = reader.string();
                    break;
                case /* repeated injective.oracle.v1beta1.ChainlinkReport reports */ 2:
                    message.reports.push(ChainlinkReport.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayChainlinkPrices, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sender = 1; */
        if (message.sender !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sender);
        /* repeated injective.oracle.v1beta1.ChainlinkReport reports = 2; */
        for (let i = 0; i < message.reports.length; i++)
            ChainlinkReport.internalBinaryWrite(message.reports[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayChainlinkPrices
 */
export const MsgRelayChainlinkPrices = new MsgRelayChainlinkPrices$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgRelayChainlinkPricesResponse$Type extends MessageType<MsgRelayChainlinkPricesResponse> {
    constructor() {
        super("injective.oracle.v1beta1.MsgRelayChainlinkPricesResponse", []);
    }
    create(value?: PartialMessage<MsgRelayChainlinkPricesResponse>): MsgRelayChainlinkPricesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgRelayChainlinkPricesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgRelayChainlinkPricesResponse): MsgRelayChainlinkPricesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgRelayChainlinkPricesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgRelayChainlinkPricesResponse
 */
export const MsgRelayChainlinkPricesResponse = new MsgRelayChainlinkPricesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParams$Type extends MessageType<MsgUpdateParams> {
    constructor() {
        super("injective.oracle.v1beta1.MsgUpdateParams", [
            { no: 1, name: "authority", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "cosmos_proto.scalar": "cosmos.AddressString" } },
            { no: 2, name: "params", kind: "message", T: () => Params, options: { "gogoproto.nullable": false } }
        ], { "amino.name": "oracle/MsgUpdateParams", "cosmos.msg.v1.signer": ["authority"] });
    }
    create(value?: PartialMessage<MsgUpdateParams>): MsgUpdateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.authority = "";
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParams): MsgUpdateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority */ 1:
                    message.authority = reader.string();
                    break;
                case /* injective.oracle.v1beta1.Params params */ 2:
                    message.params = Params.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority = 1; */
        if (message.authority !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authority);
        /* injective.oracle.v1beta1.Params params = 2; */
        if (message.params)
            Params.internalBinaryWrite(message.params, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgUpdateParams
 */
export const MsgUpdateParams = new MsgUpdateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MsgUpdateParamsResponse$Type extends MessageType<MsgUpdateParamsResponse> {
    constructor() {
        super("injective.oracle.v1beta1.MsgUpdateParamsResponse", []);
    }
    create(value?: PartialMessage<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<MsgUpdateParamsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MsgUpdateParamsResponse): MsgUpdateParamsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MsgUpdateParamsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message injective.oracle.v1beta1.MsgUpdateParamsResponse
 */
export const MsgUpdateParamsResponse = new MsgUpdateParamsResponse$Type();
/**
 * @generated ServiceType for protobuf service injective.oracle.v1beta1.Msg
 */
export const Msg = new ServiceType("injective.oracle.v1beta1.Msg", [
    { name: "RelayProviderPrices", options: {}, I: MsgRelayProviderPrices, O: MsgRelayProviderPricesResponse },
    { name: "RelayPriceFeedPrice", options: {}, I: MsgRelayPriceFeedPrice, O: MsgRelayPriceFeedPriceResponse },
    { name: "RelayCoinbaseMessages", options: {}, I: MsgRelayCoinbaseMessages, O: MsgRelayCoinbaseMessagesResponse },
    { name: "RelayStorkMessage", options: {}, I: MsgRelayStorkPrices, O: MsgRelayStorkPricesResponse },
    { name: "RelayPythPrices", options: {}, I: MsgRelayPythPrices, O: MsgRelayPythPricesResponse },
    { name: "RelayChainlinkPrices", options: {}, I: MsgRelayChainlinkPrices, O: MsgRelayChainlinkPricesResponse },
    { name: "UpdateParams", options: {}, I: MsgUpdateParams, O: MsgUpdateParamsResponse }
], { "cosmos.msg.v1.service": true });
